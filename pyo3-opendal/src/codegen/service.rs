// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

use crate::codegen::parser::{ConfigType, parse_service_config};
use anyhow::{Result, anyhow};
use cargo_metadata::MetadataCommand;
use quote::{format_ident, quote};
use std::path::{Path, PathBuf};

pub fn generate(service_name: &str, package_path: &Path) -> Result<String> {
    // 1. Find dependency path
    let dep_path = find_dependency_path(package_path, service_name)?;
    let config_path = dep_path.join("src/config.rs");

    if !config_path.exists() {
        return Err(anyhow!("Config file not found at {:?}", config_path));
    }

    // 2. Parse config
    let service_config = parse_service_config(&config_path, service_name)?;

    let service_pascal = service_to_pascal(service_name);
    let service_snake = service_name.replace('-', "_");
    let py_service_ident = format_ident!("Py{}Service", service_pascal);
    let config_ident = format_ident!("{}Config", service_pascal);
    let service_module = format_ident!("opendal_service_{}", service_snake);
    let service_pascal_lit = service_pascal.clone();

    // 3. Generate struct fields
    let mut fields = Vec::new();
    let mut from_impls = Vec::new();

    for field in service_config.config {
        let field_name = format_ident!("{}", field.name);

        // Handle types
        let (ty, _) = match field.value {
            ConfigType::Bool => (quote!(bool), false),
            ConfigType::String | ConfigType::Duration => (quote!(String), false),
            ConfigType::Usize => (quote!(usize), false),
            ConfigType::U64 => (quote!(u64), false),
            ConfigType::I64 => (quote!(i64), false),
            ConfigType::U32 => (quote!(u32), false),
            ConfigType::U16 => (quote!(u16), false),
            ConfigType::Vec => (quote!(Vec<String>), false),
        };

        // Determine if we wrap in Option
        // Logic: if it's already an option upstream (field.is_option) OR it's a bool (which we treat as optional in python)
        let effective_optional = field.is_option || field.value == ConfigType::Bool;
        let field_type = if effective_optional {
            quote!(Option<#ty>)
        } else {
            quote!(#ty)
        };

        // Comments
        let doc_comments = field.comments.lines().map(|line| quote!(#[doc = #line]));

        // Deprecation
        let deprecation = if let Some(dep) = field.deprecated {
            let since = dep.since;
            let note = dep.note;
            quote!(#[deprecated(since = #since, note = #note)])
        } else {
            quote!()
        };

        fields.push(quote! {
            #(#doc_comments)*
            #deprecation
            pub #field_name: #field_type
        });

        // From impl logic
        if field.is_option {
            // Upstream is Option<T>, we have Option<T>. Direct assignment.
            from_impls.push(quote! {
                cfg.#field_name = opts.#field_name;
            });
        } else if field.value == ConfigType::Bool {
            // Upstream is bool, we have Option<bool>. Use if let Some.
            from_impls.push(quote! {
                if let Some(v) = opts.#field_name {
                    cfg.#field_name = v;
                }
            });
        } else {
            // Upstream is T, we have T. Direct assignment.
            // Note: This assumes parsing logic sets `optional` correctly for non-option types.
            // Actually, my parser logic for `effective_optional` above matches `parser.rs`.
            // Wait, if parser says `is_option` is false, and it's NOT bool, then `effective_optional` is false.
            // So we have `T`.
            from_impls.push(quote! {
                cfg.#field_name = opts.#field_name;
            });
        }
    }

    let code = quote! {
        //! This file is automatically generated by `pyo3_opendal::codegen::generate_service_stub`

        use #service_module::#config_ident;

        use pyo3::prelude::*;
        use pyo3::types::PyDict;
        use pyo3_opendal::FromConfigurator;
        use pyo3_opendal::ToStringMap;
        use pyo3_opendal::export::OpendalOperator;
        use pyo3_opendal::ocore::Configurator;
        use pyo3_opendal::ocore::Operator;
        use pyo3_opendal::ocore::OperatorUri;
        use pyo3_stub_gen::derive::*;
        use serde::{Deserialize, Serialize};
        use std::collections::HashMap;

        #[gen_stub_pyclass]
        #[pyclass(get_all, set_all, name = #service_pascal_lit)]
        #[derive(Clone, Default, Serialize, Deserialize)]
        #[allow(deprecated)]
        pub struct #py_service_ident {
            #(#fields),*
        }

        impl From<#py_service_ident> for #config_ident {
            #[allow(deprecated)]
            fn from(opts: #py_service_ident) -> Self {
                let mut cfg = #config_ident::default();
                #(#from_impls)*
                cfg
            }
        }

        #[gen_stub_pymethods]
        #[pymethods]
        impl #py_service_ident {
            #[staticmethod]
            #[pyo3(signature = (**kwargs))]
            pub fn from_config(kwargs: Option<&Bound<PyDict>>) -> PyResult<Self> {
                let map: HashMap<String, String> =
                    kwargs.map(|d| d.extract()).transpose()?.unwrap_or_default();
                let cfg = #config_ident::from_iter(map).map_err(pyo3_opendal::format_pyerr)?;

                Self::from_configurator(&cfg)
            }

            #[staticmethod]
            #[pyo3(signature = (uri, **kwargs))]
            pub fn from_uri(uri: &str, kwargs: Option<&Bound<PyDict>>) -> PyResult<Self> {
                let map: HashMap<String, String> =
                    kwargs.map(|d| d.extract()).transpose()?.unwrap_or_default();

                let cfg = OperatorUri::new(uri, map)
                    .and_then(|u| #config_ident::from_uri(&u))
                    .map_err(pyo3_opendal::format_pyerr)?;

                Self::from_configurator(&cfg)
            }

            #[gen_stub(override_return_type(type_repr = "opendal.AsyncOperator", imports=("opendal")))]
            pub fn to_async_operator(&self) -> PyResult<OpendalOperator> {
                let cfg: #config_ident = self.clone().into();
                let map = cfg.to_string_map()?;
                let op = Operator::from_config(cfg)
                    .map_err(pyo3_opendal::format_pyerr)?
                    .finish();

                Ok(OpendalOperator::new(op, map, true))
            }

            #[gen_stub(override_return_type(type_repr = "opendal.Operator", imports=("opendal")))]
            pub fn to_operator(&self) -> PyResult<OpendalOperator> {
                let op = self.to_async_operator()?;
                Ok(OpendalOperator::new(op.op, op.map, false))
            }
        }
    };

    Ok(code.to_string())
}

fn find_dependency_path(package_path: &Path, service_name: &str) -> Result<PathBuf> {
    let manifest_path = package_path.join("Cargo.toml").canonicalize()?;

    let metadata = MetadataCommand::new()
        .manifest_path(&manifest_path)
        .exec()?;

    let dep_name = format!("opendal-service-{}", service_name);

    let pkg = metadata
        .packages
        .iter()
        .find(|p| p.name == dep_name && p.source.is_some())
        .ok_or_else(|| anyhow!("Could not find dependency package {}", dep_name))?;

    let dep_manifest_path = pkg.manifest_path.clone().into_std_path_buf();
    Ok(dep_manifest_path.parent().unwrap().to_path_buf())
}

fn service_to_pascal(service: &str) -> String {
    let mut result = String::with_capacity(service.len());
    let mut capitalize = true;

    for &b in service.as_bytes() {
        if b == b'_' || b == b'-' {
            capitalize = true;
        } else if capitalize {
            result.push((b as char).to_ascii_uppercase());
            capitalize = false;
        } else {
            result.push(b as char);
        }
    }

    result
}
