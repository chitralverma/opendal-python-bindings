// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

use crate::codegen::parser::{ConfigType, parse_service_config};
use crate::codegen::types::get_type_info_from_config_type;
use crate::codegen::utils::{find_dependency_path, to_pascal};
use anyhow::{Result, anyhow};
use quote::{format_ident, quote};
use std::path::Path;

pub fn generate(service_name: &str, package_path: &Path) -> Result<String> {
    // 1. Find dependency path
    let dep_name = format!("opendal-service-{}", service_name);
    let dep_path = find_dependency_path(package_path, &dep_name)?;
    let config_path = dep_path.join("src/config.rs");

    if !config_path.exists() {
        return Err(anyhow!("Config file not found at {:?}", config_path));
    }
    println!("cargo:rerun-if-changed={}", config_path.display());

    // 2. Parse config
    let mut service_config = parse_service_config(&config_path, service_name)?;
    // Sort config fields by name to ensure deterministic order
    service_config.config.sort_by(|a, b| a.name.cmp(&b.name));

    let service_pascal = to_pascal(service_name);
    let service_snake = service_name.replace('-', "_");
    let py_service_ident = format_ident!("Py{}Service", service_pascal);
    let config_ident = format_ident!("{}Config", service_pascal);
    let scheme_ident = format_ident!("{}_SCHEME", service_snake.to_uppercase());
    let service_module = format_ident!("opendal_service_{}", service_snake);
    let service_pascal_lit = service_pascal.clone();

    // 3. Generate struct fields
    let mut fields = Vec::new();
    let mut from_impls = Vec::new();

    for field in service_config.config {
        let field_name = format_ident!("{}", field.name);

        // Handle types
        let type_info = get_type_info_from_config_type(field.value);
        let ty = type_info.rust_type;

        // Determine if we wrap in Option
        // Logic: if it's already an option upstream (field.is_option) OR it's a bool (which we treat as optional in python)
        let effective_optional = field.is_option || field.value == ConfigType::Bool;
        let field_type = if effective_optional {
            quote!(Option<#ty>)
        } else {
            quote!(#ty)
        };

        // Comments
        let doc_comments = field.comments.lines().map(|line| quote!(#[doc = #line]));

        // Deprecation
        let deprecation = if let Some(dep) = field.deprecated {
            let since = dep.since;
            let note = dep.note;
            quote!(#[deprecated(since = #since, note = #note)])
        } else {
            quote!()
        };

        fields.push(quote! {
            #(#doc_comments)*
            #deprecation
            pub #field_name: #field_type
        });

        // From impl logic
        if field.is_option {
            // Upstream is Option<T>, we have Option<T>. Direct assignment.
            from_impls.push(quote! {
                cfg.#field_name = opts.#field_name;
            });
        } else if field.value == ConfigType::Bool {
            // Upstream is bool, we have Option<bool>. Use if let Some.
            from_impls.push(quote! {
                if let Some(v) = opts.#field_name {
                    cfg.#field_name = v;
                }
            });
        } else {
            // Upstream is T, we have T. Direct assignment.
            from_impls.push(quote! {
                cfg.#field_name = opts.#field_name;
            });
        }
    }

    let code = quote! {
        //! This file is automatically generated by `pyo3_opendal::codegen::generate_service_stub`
        #![allow(clippy::possible_missing_else)]

        use #service_module::{#scheme_ident, #config_ident};

        use pyo3::prelude::*;
        use pyo3::types::IntoPyDict;
        use pyo3::types::PyDict;
        use pyo3_opendal::FromConfigurator;
        use pyo3_opendal::ToStringMap;
        use pyo3_opendal::export::OpendalOperator;
        use pyo3_opendal::ocore::Configurator;
        use pyo3_opendal::ocore::OperatorUri;
        use pyo3_stub_gen::derive::*;
        use serde::{Deserialize, Serialize};
        use std::collections::HashMap;

        #[gen_stub_pyclass]
        #[pyclass(get_all, set_all, name = #service_pascal_lit)]
        #[derive(Clone, Default, Serialize, Deserialize)]
        #[allow(deprecated)]
        pub struct #py_service_ident {
            #(#fields),*
        }

        impl From<#py_service_ident> for #config_ident {
            #[allow(deprecated)]
            fn from(opts: #py_service_ident) -> Self {
                let mut cfg = #config_ident::default();
                #(#from_impls)*
                cfg
            }
        }

        #[gen_stub_pymethods]
        #[pymethods]
        impl #py_service_ident {
            #[new]
            #[pyo3(signature = (*, **kwargs))]
            fn new(kwargs: Option<&Bound<PyDict>>) -> PyResult<Self> {
                Self::from_config(kwargs)
            }

            #[staticmethod]
            #[pyo3(signature = (**kwargs))]
            pub fn from_config(kwargs: Option<&Bound<PyDict>>) -> PyResult<Self> {
                let map: HashMap<String, String> =
                    kwargs.map(|d| d.extract()).transpose()?.unwrap_or_default();
                let cfg = #config_ident::from_iter(map).map_err(pyo3_opendal::format_pyerr)?;

                Self::from_configurator(&cfg)
            }

            #[staticmethod]
            #[pyo3(signature = (uri, **kwargs))]
            pub fn from_uri(uri: &str, kwargs: Option<&Bound<PyDict>>) -> PyResult<Self> {
                let map: HashMap<String, String> =
                    kwargs.map(|d| d.extract()).transpose()?.unwrap_or_default();

                let cfg = OperatorUri::new(uri, map)
                    .and_then(|u| #config_ident::from_uri(&u))
                    .map_err(pyo3_opendal::format_pyerr)?;

                Self::from_configurator(&cfg)
            }

            #[gen_stub(override_return_type(type_repr = "opendal.operator.AsyncOperator", imports=("opendal")))]
            pub fn to_async_operator(&self, py: Python) -> PyResult<OpendalOperator> {
                let cfg: #config_ident = self.clone().into();
                let map = cfg.to_string_map()?;
                crate::__build_operator__(#scheme_ident.into(), true, Some(&map.into_py_dict(py)?))
            }

            #[gen_stub(override_return_type(type_repr = "opendal.operator.Operator", imports=("opendal")))]
            pub fn to_operator(&self, py: Python) -> PyResult<OpendalOperator> {
                let cfg: #config_ident = self.clone().into();
                let map = cfg.to_string_map()?;
                crate::__build_operator__(#scheme_ident.into(), false, Some(&map.into_py_dict(py)?))
            }
        }
    };

    Ok(code.to_string())
}
