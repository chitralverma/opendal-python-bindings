// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#![doc = r" This file is automatically generated by `pyo3_opendal::codegen::generate_service_stub`"]
#![allow(clippy::possible_missing_else)]
use opendal_service_fs::{FS_SCHEME, FsConfig};
use pyo3::prelude::*;
use pyo3::types::IntoPyDict;
use pyo3::types::PyDict;
use pyo3_opendal::FromConfigurator;
use pyo3_opendal::ToStringMap;
use pyo3_opendal::export::OpendalOperator;
use pyo3_opendal::ocore::Configurator;
use pyo3_opendal::ocore::OperatorUri;
use pyo3_stub_gen::derive::*;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
#[gen_stub_pyclass]
#[pyclass(get_all, set_all, module = "opendal_service_fs", name = "Fs")]
#[derive(Clone, Default, Serialize, Deserialize)]
#[allow(deprecated)]
pub struct PyFsService {
    #[doc = "tmp dir for atomic write"]
    pub atomic_write_dir: Option<String>,
    #[doc = "root dir for backend"]
    pub root: Option<String>,
}
impl From<PyFsService> for FsConfig {
    #[allow(deprecated)]
    fn from(opts: PyFsService) -> Self {
        let mut cfg = FsConfig::default();
        cfg.atomic_write_dir = opts.atomic_write_dir;
        cfg.root = opts.root;
        cfg
    }
}
#[gen_stub_pymethods]
#[pymethods]
impl PyFsService {
    #[new]
    # [pyo3 (signature = (* , * * kwargs))]
    fn new(kwargs: Option<&Bound<PyDict>>) -> PyResult<Self> {
        Self::from_config(kwargs)
    }
    #[staticmethod]
    # [pyo3 (signature = (* * kwargs))]
    pub fn from_config(kwargs: Option<&Bound<PyDict>>) -> PyResult<Self> {
        let map: HashMap<String, String> =
            kwargs.map(|d| d.extract()).transpose()?.unwrap_or_default();
        let cfg = FsConfig::from_iter(map).map_err(pyo3_opendal::format_pyerr)?;
        Self::from_configurator(&cfg)
    }
    #[staticmethod]
    # [pyo3 (signature = (uri , * * kwargs))]
    pub fn from_uri(uri: &str, kwargs: Option<&Bound<PyDict>>) -> PyResult<Self> {
        let map: HashMap<String, String> =
            kwargs.map(|d| d.extract()).transpose()?.unwrap_or_default();
        let cfg = OperatorUri::new(uri, map)
            .and_then(|u| FsConfig::from_uri(&u))
            .map_err(pyo3_opendal::format_pyerr)?;
        Self::from_configurator(&cfg)
    }
    # [gen_stub (override_return_type (type_repr = "opendal.AsyncOperator" , imports = ("opendal")))]
    pub fn to_async_operator(&self, py: Python) -> PyResult<OpendalOperator> {
        let cfg: FsConfig = self.clone().into();
        let map = cfg.to_string_map()?;
        crate::__build_operator__(FS_SCHEME.into(), true, Some(&map.into_py_dict(py)?))
    }
    # [gen_stub (override_return_type (type_repr = "opendal.Operator" , imports = ("opendal")))]
    pub fn to_operator(&self, py: Python) -> PyResult<OpendalOperator> {
        let cfg: FsConfig = self.clone().into();
        let map = cfg.to_string_map()?;
        crate::__build_operator__(FS_SCHEME.into(), false, Some(&map.into_py_dict(py)?))
    }
}
